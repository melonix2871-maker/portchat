<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Portable AI Chat</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: #0f1115; color: #e6e6e6; }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #1e2230; background: #12151c; position: sticky; top: 0; z-index: 10; }
    header .title { font-weight: 600; }
    header .status { font-size: 12px; opacity: 0.8; }
    main { display: grid; grid-template-columns: 320px 1fr; gap: 12px; padding: 12px; }
    @media (max-width: 900px) { main { grid-template-columns: 1fr; } }
    .panel { border: 1px solid #1e2230; border-radius: 10px; background: #12151c; }
    .panel h2 { margin: 0; padding: 10px 12px; font-size: 14px; border-bottom: 1px solid #1e2230; opacity: 0.9; }
    .panel .content { padding: 12px; }
    .row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
    label { font-size: 12px; opacity: 0.8; min-width: 110px; }
    input[type="text"], input[type="number"], textarea, select { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid #2a3142; background: #0f1320; color: #e6e6e6; }
    textarea { min-height: 80px; resize: vertical; }
    .messages { height: 60vh; overflow: auto; padding: 12px; display: flex; flex-direction: column; gap: 12px; }
    .msg { padding: 10px 12px; border-radius: 10px; line-height: 1.5; white-space: pre-wrap; }
    .user { background: #16335a; }
    .assistant { background: #1a1f2d; }
    .sys { background: #2a1f3a; }
    .composer { display: flex; gap: 8px; padding: 12px; border-top: 1px solid #1e2230; }
    .composer textarea { height: 80px; }
    button { padding: 10px 12px; border: 1px solid #2a3142; background: #1a2235; color: #e6e6e6; border-radius: 8px; cursor: pointer; }
    button:hover { filter: brightness(1.1); }
    .btn-secondary { background: #242a3f; }
    .btn-danger { background: #482020; border-color: #6a2a2a; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #2a3142; font-size: 11px; }
    .progress { height: 6px; background: #1e2230; border-radius: 999px; overflow: hidden; }
    .progress > div { height: 100%; background: #3a7bfd; width: 0%; transition: width 0.2s ease; }
    .hidden { display: none; }
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; }
    .modal { width: min(720px, 92vw); background: #12151c; border: 1px solid #1e2230; border-radius: 10px; }
    .modal header { padding: 10px 12px; border-bottom: 1px solid #1e2230; }
    .modal .content { padding: 12px; font-size: 14px; line-height: 1.6; }
    .tips-list { margin: 0; padding-left: 18px; }
  </style>
</head>
<body>
  <header>
    <div class="title">Portable AI Chat</div>
    <div class="status">
      <span id="gpuStatus" class="badge">WebGPU: checking…</span>
      <span id="engineStatus" class="badge">Engine: idle</span>
      <span id="apiStatus" class="badge">API: n/a</span>
    </div>
  </header>
  <main>
    <section class="panel">
      <h2>Settings</h2>
      <div class="content">
        <div class="row">
          <label>Mode</label>
          <select id="mode">
            <option value="browser">Browser (WebLLM)</option>
            <option value="remote">Remote Server</option>
          </select>
        </div>
        <div class="row browser-only">
          <label>Model ID</label>
          <input id="modelId" type="text" value="Phi-3-mini-4k-instruct-q4f16_1-MLC">
        </div>
        <div class="row remote-only hidden">
          <label>Remote API Base</label>
          <input id="apiBase" type="text" placeholder="https://api.example.com">
        </div>
        <div class="row">
          <label>Temperature</label>
          <input id="temperature" type="number" step="0.1" min="0" max="2" value="0.7">
        </div>
        <div class="row">
          <label>Top P</label>
          <input id="topP" type="number" step="0.05" min="0" max="1" value="0.9">
        </div>
        <div class="row">
          <label>Max Tokens</label>
          <input id="maxTokens" type="number" min="1" max="4096" value="512">
        </div>
        <div class="row">
          <label>System Prompt</label>
          <textarea id="systemPrompt">You are a helpful assistant.</textarea>
        </div>
        <div class="row">
          <label>Model Load</label>
          <div class="progress" style="flex:1"><div id="loadProgress"></div></div>
        </div>
        <div class="row">
          <label>GPU Details</label>
          <div id="gpuDetails" style="font-size:12px; opacity:0.85">Detecting…</div>
        </div>
        <div class="row">
          <button id="reloadModel" class="btn-secondary">Reload Model</button>
          <button id="clearChat" class="btn-secondary">Clear Chat</button>
          <button id="tipsBtn" class="btn-secondary">Performance Tips</button>
          <button id="checkApiBtn" class="btn-secondary">Check API</button>
        </div>
      </div>
    </section>
    <section class="panel" style="grid-column: span 1 / -1">
      <h2>Chat</h2>
      <div class="messages" id="messages"></div>
      <div class="composer">
        <textarea id="userInput" placeholder="Type your message…"></textarea>
        <div style="display:flex; flex-direction:column; gap:8px; min-width:160px">
          <button id="sendBtn">Send</button>
          <button id="stopBtn" class="btn-danger">Stop</button>
        </div>
      </div>
    </section>
  </main>
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";
    const gpuStatus = document.getElementById("gpuStatus");
    const engineStatus = document.getElementById("engineStatus");
    const modeSel = document.getElementById("mode");
    const modelIdInput = document.getElementById("modelId");
    const apiBaseInput = document.getElementById("apiBase");
    const temperatureInput = document.getElementById("temperature");
    const topPInput = document.getElementById("topP");
    const maxTokensInput = document.getElementById("maxTokens");
    const systemPromptInput = document.getElementById("systemPrompt");
    const messagesEl = document.getElementById("messages");
    const userInput = document.getElementById("userInput");
    const sendBtn = document.getElementById("sendBtn");
    const stopBtn = document.getElementById("stopBtn");
    const reloadBtn = document.getElementById("reloadModel");
    const clearChatBtn = document.getElementById("clearChat");
    const loadBar = document.getElementById("loadProgress");
    const apiStatus = document.getElementById("apiStatus");
    const gpuDetails = document.getElementById("gpuDetails");
    const tipsBtn = document.getElementById("tipsBtn");
    const checkApiBtn = document.getElementById("checkApiBtn");

    const browserOnly = document.querySelectorAll(".browser-only");
    const remoteOnly = document.querySelectorAll(".remote-only");

    const storage = {
      load() {
        try {
          const s = JSON.parse(localStorage.getItem("portable_ai_chat") || "{}");
          if (s.mode) modeSel.value = s.mode;
          if (s.modelId) modelIdInput.value = s.modelId;
          if (s.apiBase) apiBaseInput.value = s.apiBase;
          if (s.temperature != null) temperatureInput.value = s.temperature;
          if (s.topP != null) topPInput.value = s.topP;
          if (s.maxTokens != null) maxTokensInput.value = s.maxTokens;
          if (s.systemPrompt != null) systemPromptInput.value = s.systemPrompt;
          if (Array.isArray(s.messages)) {
            messages = s.messages;
            renderAll();
          }
        } catch {}
      },
      save() {
        const s = {
          mode: modeSel.value,
          modelId: modelIdInput.value,
          apiBase: apiBaseInput.value,
          temperature: parseFloat(temperatureInput.value),
          topP: parseFloat(topPInput.value),
          maxTokens: parseInt(maxTokensInput.value, 10),
          systemPrompt: systemPromptInput.value,
          messages
        };
        localStorage.setItem("portable_ai_chat", JSON.stringify(s));
      }
    };

    let engine = null;
    let streaming = false;
    let stopFlag = false;
    let messages = [];

    function setStatus(text) { engineStatus.textContent = "Engine: " + text; }
    function addMsg(role, content) {
      const m = { role, content };
      messages.push(m);
      const div = document.createElement("div");
      div.className = "msg " + (role === "user" ? "user" : role === "assistant" ? "assistant" : "sys");
      div.textContent = content;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      storage.save();
      return m;
    }
    function renderAll() {
      messagesEl.innerHTML = "";
      for (const m of messages) {
        const div = document.createElement("div");
        div.className = "msg " + (m.role === "user" ? "user" : m.role === "assistant" ? "assistant" : "sys");
        div.textContent = m.content;
        messagesEl.appendChild(div);
      }
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    function updateModeUI() {
      const isBrowser = modeSel.value === "browser";
      browserOnly.forEach(e => e.classList.toggle("hidden", !isBrowser));
      remoteOnly.forEach(e => e.classList.toggle("hidden", isBrowser));
    }
    function webgpuDetect() {
      const supported = !!navigator.gpu;
      gpuStatus.textContent = "WebGPU: " + (supported ? "available" : "unavailable");
      gpuStatus.style.borderColor = supported ? "#2a3142" : "#6a2a2a";
    }
    async function populateGPUDetails() {
      try {
        if (!navigator.gpu) { gpuDetails.textContent = "WebGPU unavailable"; return; }
        const adapter = await navigator.gpu.requestAdapter(); // no powerPreference (ignored on Windows)
        if (!adapter) { gpuDetails.textContent = "No adapter"; return; }
        const lim = adapter.limits;
        const lines = [
          "isFallbackAdapter: " + (adapter.isFallbackAdapter ? "yes" : "no"),
          "maxBufferSize: " + lim.maxBufferSize,
          "maxStorageBufferBindingSize: " + lim.maxStorageBufferBindingSize,
          "maxComputeWorkgroupSize: [" + lim.maxComputeWorkgroupSizeX + "," + lim.maxComputeWorkgroupSizeY + "," + lim.maxComputeWorkgroupSizeZ + "]",
          "maxComputeInvocationsPerWorkgroup: " + lim.maxComputeInvocationsPerWorkgroup
        ];
        gpuDetails.textContent = lines.join(" • ");
      } catch (e) {
        gpuDetails.textContent = "GPU info error";
      }
    }
    async function ensureEngine() {
      if (modeSel.value !== "browser") return;
      const modelId = modelIdInput.value.trim();
      setStatus("loading");
      loadBar.style.width = "0%";
      engine = await webllm.CreateMLCEngine(modelId, {
        initProgressCallback: (p) => {
          const progress = p.progress || 0;
          loadBar.style.width = Math.round(progress * 100) + "%";
        }
      }).catch(e => { setStatus("error"); throw e; });
      setStatus("ready");
    }
    async function reloadModel() {
      stopFlag = true;
      streaming = false;
      setStatus("reloading");
      messages = [];
      renderAll();
      await ensureEngine();
      setStatus("ready");
      storage.save();
    }
    async function send() {
      const text = userInput.value.trim();
      if (!text) return;
      userInput.value = "";
      const system = systemPromptInput.value.trim();
      const temp = parseFloat(temperatureInput.value);
      const top_p = parseFloat(topPInput.value);
      const max_tokens = parseInt(maxTokensInput.value, 10);
      addMsg("user", text);
      const assistantMsg = addMsg("assistant", "");
      stopFlag = false;
      streaming = true;

      if (modeSel.value === "browser") {
        if (!engine) await ensureEngine();
        const msgs = [];
        if (system) msgs.push({ role: "system", content: system });
        for (const m of messages) {
          if (m.role === "user" || m.role === "assistant") msgs.push({ role: m.role, content: m.content });
        }
        try {
          setStatus("generating");
          const chunks = await engine.chat.completions.create({
            messages: msgs,
            temperature: temp,
            top_p,
            max_tokens,
            stream: true,
            stream_options: { include_usage: true }
          });
          let acc = "";
          for await (const chunk of chunks) {
            if (stopFlag) break;
            const delta = chunk.choices?.[0]?.delta?.content || "";
            if (delta) {
              acc += delta;
              assistantMsg.content = acc;
              messagesEl.lastChild.textContent = acc;
              messagesEl.scrollTop = messagesEl.scrollHeight;
            }
          }
          if (!stopFlag) {
            const finalText = await engine.getMessage();
            assistantMsg.content = finalText;
            messagesEl.lastChild.textContent = finalText;
          }
        } catch (e) {
          assistantMsg.content = "[Error] " + (e?.message || String(e));
          messagesEl.lastChild.textContent = assistantMsg.content;
        } finally {
          streaming = false;
          setStatus("ready");
          storage.save();
        }
      } else {
        const apiBase = apiBaseInput.value.trim();
        if (!apiBase) {
          assistantMsg.content = "Set Remote API Base to use remote mode.";
          messagesEl.lastChild.textContent = assistantMsg.content;
          streaming = false;
          setStatus("idle");
          return;
        }
        apiStatus.textContent = "API: connecting…";
        const msgs = [];
        if (system) msgs.push({ role: "system", content: system });
        for (const m of messages) {
          if (m.role === "user" || m.role === "assistant") msgs.push({ role: m.role, content: m.content });
        }
        try {
          setStatus("generating");
          const res = await fetch(apiBase.replace(/\/+$/, "") + "/v1/chat/completions", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              messages: msgs,
              temperature: temp,
              top_p,
              max_tokens,
              stream: true
            })
          });
          apiStatus.textContent = "API: connected";
          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let acc = "";
          while (true) {
            const { value, done } = await reader.read();
            if (done || stopFlag) break;
            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split("\n");
            for (const line of lines) {
              if (!line.startsWith("data:")) continue;
              const data = line.slice(5).trim();
              if (!data || data === "[DONE]") continue;
              let obj;
              try { obj = JSON.parse(data); } catch { continue; }
              const delta = obj.choices?.[0]?.delta?.content || "";
              if (delta) {
                acc += delta;
                assistantMsg.content = acc;
                messagesEl.lastChild.textContent = acc;
                messagesEl.scrollTop = messagesEl.scrollHeight;
              }
            }
          }
        } catch (e) {
          assistantMsg.content = "[Error] " + (e?.message || String(e));
          messagesEl.lastChild.textContent = assistantMsg.content;
          apiStatus.textContent = "API: error";
        } finally {
          streaming = false;
          setStatus("ready");
          storage.save();
        }
      }
    }
    function stop() { if (streaming) { stopFlag = true; setStatus("stopped"); } }
    async function clearChat() {
      messages = [];
      messagesEl.innerHTML = "";
      if (engine) await engine.resetChat(true);
      storage.save();
    }
    async function checkApi() {
      const apiBase = apiBaseInput.value.trim();
      if (!apiBase) { apiStatus.textContent = "API: n/a"; return; }
      try {
        apiStatus.textContent = "API: checking…";
        const r = await fetch(apiBase.replace(/\/+$/, "") + "/v1/models");
        apiStatus.textContent = r.ok ? "API: connected" : "API: error";
      } catch { apiStatus.textContent = "API: error"; }
    }

    modeSel.addEventListener("change", () => { updateModeUI(); storage.save(); });
    reloadBtn.addEventListener("click", reloadModel);
    clearChatBtn.addEventListener("click", clearChat);
    sendBtn.addEventListener("click", send);
    stopBtn.addEventListener("click", stop);
    userInput.addEventListener("keydown", (e) => { if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) send(); });
    checkApiBtn.addEventListener("click", checkApi);

    updateModeUI();
    webgpuDetect();
    populateGPUDetails();
    storage.load();
    if (modeSel.value === "browser" && navigator.gpu) ensureEngine();
  </script>
  <div id="tipsModal" class="modal-backdrop">
    <div class="modal">
      <header>
        <div class="title">Performance Tips (Windows + NVIDIA/AMD)</div>
      </header>
      <div class="content">
        <p>On Windows, Chromium ignores powerPreference when selecting the WebGPU adapter. Use system settings to prefer the discrete GPU:</p>
        <ul class="tips-list">
          <li>Windows Settings → System → Display → Graphics → Add your browser (Chrome/Edge) → Options → High performance.</li>
          <li>NVIDIA Control Panel → Manage 3D settings → Program settings → Select your browser → Preferred graphics processor: High-performance NVIDIA.</li>
          <li>AMD Software: Set the browser to use the High performance GPU.</li>
        </ul>
        <p>If GPU performance is limited, choose a smaller model in Browser mode or switch to Remote mode with an API endpoint.</p>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="closeTips" class="btn-secondary">Close</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    (function(){
      const tipsBtn = document.getElementById("tipsBtn");
      const backdrop = document.getElementById("tipsModal");
      const closeBtn = document.getElementById("closeTips");
      tipsBtn.addEventListener("click", () => { backdrop.style.display = "flex"; });
      closeBtn.addEventListener("click", () => { backdrop.style.display = "none"; });
      backdrop.addEventListener("click", (e) => { if (e.target === backdrop) backdrop.style.display = "none"; });
    })();
  </script>
</body>
</html>
